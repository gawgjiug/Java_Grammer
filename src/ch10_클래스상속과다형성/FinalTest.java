/*
package ch10_클래스상속과다형성;

public class FinalTest {
6장 클래스와 객체 부분
    클래스의 내부구조 : 필드 , 메소드 , 생성자 ,이너클래스
    클래스의 외부구조 : 패키지, 임포트 ,외부 클래스
    객체 생성에 따른 메모리 구조
-코드영역 (클래스 ,정적,상수,메서드) 스택영역(변수) 힙영역 (객체)


    필드는 클래스에 소속 된 변수이고 ,지역 변수는 메서드에 소속된 변수임
    지역변수는 강제 초기화가 안되지만 필드는 강제 초기화가 가능함
    순서 ?
    패키지 밑 임포트 밑 클래스
    생성자 메소드는 type  대신 class를 적어줌
    만약 A라는 클래스에
    Int a = 3;
    Int b = 3;
    String c = 4;
    배열 d = 5; 이렇게 되어있다면 기본타입 필드는 몇 개인가? 2개임 string과 배열 같은 경우는 참조타입

<static>
    클래스 내부에서 메소드 호출이 가능함 객체 생성 없이 호출가능
    Static 메소드는 static 메소드(필드)만 호출가능함 static이라고 붙어있는 필드나 메서드는 호출할 때도 static이라고 붙여 줘야 함
    예를들어 static void main 메소드에서 일반 필드 int a = 5; 등은 호출할 수 없음
<메소드 오버로딩>
    매개변수의 개수나 자료형이 다른 여러 동일한 이름을 갖는 메소드
    하지만 반환타입이 다르다면 오버로딩이 아님
            <생성자>
    객체 생성과 필드 초기화 역할을 하며 반환 타입이 존재하지 않음
<this>
    This 키워드는 자기 자신 객체를 가리 키는 참조 변수이고
    지역 변수는 멤버가 아니므로 this 추가할 수 없음
            <패키지 >
    같은 패지키 내에 있는 클래스를 사용할 땐 import가 필요없지만 다른 패키지 내에 존재하는 클래스를 사용할 때는 import가 필요함
    하지만 static으로 선언되어있는 필드나 메서드는 이용 불가
    Import문 예시 ch9 자바제어자 pack2부분에 잘 나와있음
    import ch09_자바제어자1.probs.prob03.pack01.A;
    클래스 접근 제어자에 public이 없으면 import 자체가 불가능함
<static 제어자>
    인스턴스 멤버는 인스턴스 필드 혹은 인스턴스 메소드를 가리 킴
    인스턴스 멤버는 객체 생성해야만 이용할 수 있는 멤버이고

-인스턴스 필드 = int m = 3 과 같은 필드를 말함

    정적 멤버에는 당연히 정적 필드 혹은 정적 메소드가 있고
    정적 필드나 메소드는 앞에 static이 들어감
    정적 멤버는 객체 생성없이 클래스 이름으로 이용할 수 있음
    자바 제어자 p292에 잘나와 있음

    정적 메소드 내부에서는 인스턴스 멤버는 사용 불가능하고 this 키워드 사용불가능 하고
    정적 멤버만 사용가능 하지만,
    인스턴스 메소드 내부에서는 인스턴스 멤버 , 정적 멤버 모두 사용가능함

    <클래스 상속과 다형성>
    부모 클래스와 자식클래스는 다른말로 슈퍼클래스, 서브클래스로도 부를 수 있음
    부모 클래스의 멤버는 자식 클래스에 상속되지만 생성자는 불가능
    Class A{} 에서 생략된 것 ? extends object
    업 캐스팅 : 자동 타입 변환
    다운 캐스팅  : 강제 타입 변환
- 기본 자료형에서 업 캐스팅 vs. 다운 캐스팅
- 업 캐스팅: 범위가 좁은 쪽에서 넓은 쪽으로
- 다운 캐스팅: 범위가 넓은 쪽에서 좁은 쪽으로
- 참조 자료형에서 업 캐스팅 vs. 다운 캐스팅
- 업 캐스팅: 범위가 넓은 쪽(자식)에서 넓은 쪽(부모)으로
- 다운 캐스팅: 범위가 좁은 쪽(부모)에서 넓은 쪽(자식)으로

    다운 캐스팅 관련 문제 나오면 ch10의 p319 ㄱ ㄱ
    만약 A클래스가 있고 B 클래스가 있다
    A ab = new B() 라는 것은 객체 B를 ab라는 이름으로 A 타입으로 선언한 것
    따라서 A가 부모 클래스이고 B가 자식 클래스 일 경우 A타입으로 객체 선언을 하였기 때문에 A타입 멤버만 사용가능
    B 클래스 멤버를 사용하고싶다?  다운 캐스팅 하면됨
    B bb = (B)ab;
bb.bcd();
    이런식으로 다운 캐스팅 하면 됨

            <instanceof> 키워드
-참조 변수 instanceof 참조타입
    기억해야 할 것은 aa라는 참조변수가 A라는 클래스의 인스턴스 이냐? 자세한 사항은
    Ch10의 존재하는 p 326 을 보면 됨
<메소드 오버라이딩>
    부모클래스로부터 상속받는 메소드와 동일한 메소드를 재정의 한것임
    반환 타입은 동일하고 , 접근 제어자 범위는 넓거나 동일함
    Ch10 의 p329 참고
    P336의 오버로딩과 오버라이딩의 차이점이 나옴 오버라이딩은 매개변수가 추가되거나 자료형이 다르고
    오버로딩은 재정의
    인스턴스 메소드만 오버라이딩이고 인스턴스 필드 혹은 정적 멤버는 오버라이딩이 아님

<super>키워드와 super() 메소드
    Super는 부모 객체를 가리키는 참조변수
    Super ()는 부모 생성자를 호출
    This 자신 객체를 가리키는 참조변수  this()는 자신의 생성자 호출
    모든 생성자 메소드 첫 줄에 반드시 this() 또는 super() 없으면 super 자동추가된 것

    <최상위 클래스 object>
    많이 사용하는 toString() 메서드는 객체 정보를 문자열로 반환하는 것임 해쉬코드 등등은
P357

        <equlas ()> 에 대하여
    String a = "lee";
    String b = "lee";
    String c = new String("lee");
    String d = new String("lee");

    a == b: true (동일한 String 객체를 참조)
            a.equals(b): true (내용이 동일)
    a == c: false (새로운 String 객체를 생성하여 참조)
            a.equals(c): true (내용이 동일)
    c == d: false (두 개의 별도의 String 객체를 생성하여 참조)
            c.equals(d): true (내용이 동일)

    힙영역에 String 객체가 존재하고 그 안에 “lee”라는 데이터가 들어가 있는데 스택 영역에 존재하는 a와 b라는 변수가 그 객체를 가리키고 있음

    <그림 관련은 ch9의 scanner5 아니면 ch10의 scanner 6_1 보면됨>


}
*/
